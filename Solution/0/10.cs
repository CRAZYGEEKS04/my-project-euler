using ProjectEuler.Common;
using ProjectEuler.Common.Miscellany;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace ProjectEuler.Solution
{
    /// <summary>
    /// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
    ///
    /// Find the sum of all the primes below two million.
    /// </summary>
    internal sealed class Problem10 : Problem
    {
        private const int upper = 2000000;

        public Problem10() : base(10) { }

        protected override string Action()
        {
            Prime prime = new Prime(upper);
            BigInteger sum = 0;

            prime.GenerateAll();
            foreach (int i in prime)
                sum += i;

            return sum.ToString();
        }
    }

    /// <summary>
    /// In the 20 * 20 grid below, four numbers along a diagonal line have been marked
    /// in red.
    ///
    /// [file D0011.txt]
    ///
    /// The product of these numbers is 26 * 63 * 78 * 14 = 1788696.
    ///
    /// What is the greatest product of four adjacent numbers in any direction (up,
    /// down, left, right, or diagonally) in the 20 * 20 grid?
    /// </summary>
    internal sealed class Problem11 : Problem
    {
        public Problem11() : base(11) { }

        private const int grid = 20;
        private const int step = 4;
        private int[,] numbers;

        protected override void PreAction(string data)
        {
            numbers = new int[grid, grid];
            int i = 0, j = 0;

            foreach (string line in data.Split('\n'))
            {
                foreach (string num in line.Trim().Split(' '))
                {
                    numbers[i, j] = int.Parse(num.Trim());
                    j++;
                }
                i++;
                j = 0;
            }
        }

        private int GetProduct(int x, int y, int xstep, int ystep)
        {
            int ret = numbers[x, y];

            for (int i = 0; i < step - 1; i++)
            {
                x += xstep;
                y += ystep;
                ret *= numbers[x, y];
            }

            return ret;
        }

        /// <summary>
        /// Only checks for p(x, y):
        ///       p * * *
        ///     * * *
        ///   *   *   *
        /// *     *     *
        /// </summary>
        protected override string Action()
        {
            int max = 0, tmp;

            for (int i = 0; i < grid; i++)
                for (int j = 0; j < grid; j++)
                {
                    if (i <= grid - step)
                    {
                        tmp = GetProduct(i, j, 1, 0);
                        if (tmp > max) max = tmp;
                    }
                    if (i <= grid - step && j <= grid - step)
                    {
                        tmp = GetProduct(i, j, 1, 1);
                        if (tmp > max) max = tmp;
                    }
                    if (j <= grid - step)
                    {
                        tmp = GetProduct(i, j, 0, 1);
                        if (tmp > max) max = tmp;
                    }
                    if (i >= step - 1 && j <= grid - step)
                    {
                        tmp = GetProduct(i, j, -1, 1);
                        if (tmp > max) max = tmp;
                    }
                }

            return max.ToString();
        }
    }

    /// <summary>
    /// The sequence of triangle numbers is generated by adding the natural numbers. So
    /// the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten
    /// terms would be:
    ///
    /// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    ///
    /// Let us list the factors of the first seven triangle numbers:
    ///
    /// 1: 1
    /// 3: 1,3
    /// 6: 1,2,3,6
    /// 10: 1,2,5,10
    /// 15: 1,3,5,15
    /// 21: 1,3,7,21
    /// 28: 1,2,4,7,14,28
    ///
    /// We can see that 28 is the first triangle number to have over five divisors.
    ///
    /// What is the value of the first triangle number to have over five hundred
    /// divisors?
    /// </summary>
    internal sealed class Problem12 : Problem
    {
        private const int maxprime = 1000000;
        private const int nfactor = 500;

        public Problem12() : base(12) { }

        protected override string Action()
        {
            Prime prime = new Prime(maxprime);
            BigInteger num = 0;

            prime.GenerateAll();
            for (int i = 1; ; i++)
            {
                num += i;
                if (Factor.GetFactorNumber(prime, num) >= nfactor)
                    break;
            }

            return num.ToString();
        }
    }

    /// <summary>
    /// Work out the first ten digits of the sum of the following one-hundred 50-digit
    /// numbers.
    ///
    /// [file D0013.txt]
    /// </summary>
    internal sealed class Problem13 : Problem
    {
        public Problem13() : base(13) { }

        private BigInteger[] numbers;

        protected override void PreAction(string data)
        {
            numbers = (from line in data.Split('\n')
                       select BigInteger.Parse(line.Trim())).ToArray();
        }

        protected override string Action()
        {
            BigInteger ret = BigInteger.Zero;

            foreach (BigInteger i in numbers)
                ret += i;

            return ret.ToString().Substring(0, 10);
        }
    }

    /// <summary>
    /// The following iterative sequence is defined for the set of positive integers:
    ///
    /// n -> n / 2 (n is even)
    /// n -> 3n + 1 (n is odd)
    ///
    /// Using the rule above and starting with 13, we generate the following sequence:
    ///
    /// 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
    ///
    /// It can be seen that this sequence (starting at 13 and finishing at 1) contains
    /// 10 terms. Although it has not been proved yet (Collatz Problem), it is thought
    /// that all starting numbers finish at 1.
    ///
    /// Which starting number, under one million, produces the longest chain?
    ///
    /// NOTE: Once the chain starts the terms are allowed to go above one million.
    /// </summary>
    internal sealed class Problem14 : Problem
    {
        private const int upper = 1000000;

        public Problem14() : base(14) { }

        private void GetLength(int[] length, BigInteger n)
        {
            LinkedList<BigInteger> path = new LinkedList<BigInteger>();
            int tmp;

            while (n >= upper || length[(int)n] == 0)
            {
                path.AddFirst(n);
                if (n % 2 == 0)
                    n /= 2;
                else
                    n = n * 3 + 1;
            }

            tmp = length[(int)n];
            foreach (BigInteger i in path)
            {
                tmp++;
                if (i < upper)
                    length[(int)i] = tmp;
            }
        }

        protected override string Action()
        {
            int[] length = new int[upper];
            int id = 1, max = 1;

            length[1] = 1;
            for (int i = 2; i < upper; i++)
                GetLength(length, i);

            for (int i = 2; i < upper; i++)
                if (length[i] > max)
                {
                    max = length[i];
                    id = i;
                }

            return id.ToString();
        }
    }

    /// <summary>
    /// Starting in the top left corner of a 2*2 grid, there are 6 routes (without
    /// backtracking) to the bottom right corner.
    ///
    /// How many routes are there through a 20*20 grid?
    /// </summary>
    internal sealed class Problem15 : Problem
    {
        public Problem15() : base(15) { }

        /// <summary>
        /// totally 20 left and 20 down moves, select 20 plots from 40 plots for down moves
        /// </summary>
        protected override string Action()
        {
            return Probability.CountCombinations(40, 20).ToString();
        }
    }

    /// <summary>
    /// 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
    ///
    /// What is the sum of the digits of the number 2^1000?
    /// </summary>
    internal sealed class Problem16 : Problem
    {
        private const int pow = 1000;

        public Problem16() : base(16) { }

        protected override string Action()
        {
            BigInteger num = 1;

            for (int i = 0; i < pow; i++)
                num <<= 1;

            return (from c in num.ToString()
                    select (int)(c - '0')).Sum().ToString();
        }
    }

    /// <summary>
    /// If the numbers 1 to 5 are written out in words: one, two, three, four, five,
    /// then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
    ///
    /// If all the numbers from 1 to 1000 (one thousand) inclusive were written out in
    /// words, how many letters would be used?
    ///
    /// NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and
    /// forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20
    /// letters. The use of "and" when writing out numbers is in compliance with
    /// British usage.
    /// </summary>
    internal sealed class Problem17 : Problem
    {
        private const int upper = 1000;

        public Problem17() : base(17) { }

        protected override string Action()
        {
            int ret = 0;

            for (int i = 1; i <= upper; i++)
            {
                string num = EnglishNumber.GetWord(i);

                ret += (from c in num
                        where c >= 'a' && c <= 'z'
                        select c).Count();
            }

            return ret.ToString();
        }
    }

    /// <summary>
    /// By starting at the top of the triangle below and moving to adjacent numbers on
    /// the row below, the maximum total from top to bottom is 23.
    ///
    /// 3
    /// 7 4
    /// 2 4 6
    /// 8 5 9 3
    ///
    /// That is, 3 + 7 + 4 + 9 = 23.
    ///
    /// Find the maximum total from top to bottom of the triangle below:
    ///
    /// [file D0018.txt]
    ///
    /// NOTE: As there are only 16384 routes, it is possible to solve this problem by
    /// trying every route. However, Problem 67, is the same challenge with a triangle
    /// containing one-hundred rows; it cannot be solved by brute force, and requires
    /// a clever method! ;o)
    /// /// </summary>
    internal sealed class Problem18 : Problem
    {
        public Problem18() : base(18) { }

        private int[][] numbers;

        protected override void PreAction(string data)
        {
            string[] lines = (from line in data.Split('\n')
                              select line.Trim()).ToArray();

            numbers = new int[lines.Length][];
            for (int i = 0; i < lines.Length; i++)
            {
                numbers[i] = (from num in lines[i].Split(' ')
                              select int.Parse(num.Trim())).ToArray();
            }
        }

        protected override string Action()
        {
            for (int i = numbers.Length - 2; i >= 0; i--)
                for (int j = 0; j < numbers[i].Length; j++)
                {
                    numbers[i][j] += numbers[i + 1][j] > numbers[i + 1][j + 1] ?
                        numbers[i + 1][j] : numbers[i + 1][j + 1];
                }

            return numbers[0][0].ToString();
        }
    }

    /// <summary>
    /// You are given the following information, but you may prefer to do some research
    /// for yourself.
    ///
    /// 1 Jan 1900 was a Monday.
    /// Thirty days has September, April, June and November.
    /// All the rest have thirty-one, Saving February alone, Which has twenty-eight,
    /// rain or shine. And on leap years, twenty-nine.
    /// A leap year occurs on any year evenly divisible by 4, but not on a century
    /// unless it is divisible by 400.
    ///
    /// How many Sundays fell on the first of the month during the twentieth century
    /// (1 Jan 1901 to 31 Dec 2000)?
    /// </summary>
    internal sealed class Problem19 : Problem
    {
        public Problem19() : base(19) { }

        protected override string Action()
        {
            int days = 0, ret = 0;

            for (int month = 1; month <= 12; month++)
                days += DateTime.DaysInMonth(1900, month);

            for (int year = 1901; year <= 2000; year++)
                for (int month = 1; month <= 12; month++)
                {
                    days += DateTime.DaysInMonth(year, month);
                    if (days % 7 == 6)
                        ret++;
                }

            return ret.ToString();
        }
    }
}